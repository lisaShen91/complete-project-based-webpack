'use strict';

exports.__esModule = true;
exports.Slider = exports.default = undefined;

var _isNan = require('babel-runtime/core-js/number/is-nan');

var _isNan2 = _interopRequireDefault(_isNan);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _class, _temp; /**
                    * Created by sylvia on 2017/10/18.
                    */


var _intact = require('intact');

var _intact2 = _interopRequireDefault(_intact);

var _index = require('./index.vdt');

var _index2 = _interopRequireDefault(_index);

require('../../styles/kpc.styl');

require('./index.styl');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Slider = (_temp = _class = function (_Intact) {
    (0, _inherits3.default)(Slider, _Intact);

    function Slider() {
        (0, _classCallCheck3.default)(this, Slider);
        return (0, _possibleConstructorReturn3.default)(this, _Intact.apply(this, arguments));
    }

    Slider.prototype.defaults = function defaults() {
        return {
            max: 100,
            min: 0,
            value: 0,
            isRange: false,
            unit: '',
            isShowEnd: true,
            isShowInput: true,
            step: 1,
            isShowStop: false,
            marks: undefined,

            _sliderValue: 0,
            _inputValue: 0,
            _isDragging: false,
            _isFirst: false,
            _isSecond: false
        };
    };

    Slider.prototype._init = function _init() {
        var _this2 = this;

        this._setFixedValue(this.get('value'));

        this.on("$change:_inputValue", function (c, val) {
            if (!_this2.get('_isDragging')) {
                _this2._setFixedValue(val);
            }
        });
        ['min', 'max', 'step', 'value'].forEach(function (item) {
            _this2.on('$receive:' + item, function () {
                if (!_this2.get('_isDragging')) {
                    _this2._setFixedValue(_this2.get('value'));
                }
            });
        });
    };

    Slider.prototype._setFixedValue = function _setFixedValue(value) {
        var fixedValue = this._getFixedValue(value);
        this.set({
            value: fixedValue,
            _inputValue: fixedValue,
            _sliderValue: fixedValue
        });
    };

    Slider.prototype._getFixedValue = function _getFixedValue(value) {
        var _get = this.get(),
            min = _get.min,
            isRange = _get.isRange;

        var fixedValue = void 0;
        if (isRange) {
            if (!Array.isArray(value)) {
                fixedValue = [min, min];
            } else {
                fixedValue = [this._fix(value[0]), this._fix(value[1])];
            }
        } else {
            fixedValue = this._fix(value);
        }

        return fixedValue;
    };

    Slider.prototype._fix = function _fix(v) {
        var _get2 = this.get(),
            step = _get2.step,
            max = _get2.max,
            min = _get2.min;

        if ((0, _isNan2.default)(Number(v))) {
            return min;
        } else if (v < min) {
            return min;
        } else if (v > max) {
            return max;
        } else {
            // for the accuracy
            var fixedValue = Number((Math.round(v / step) * step).toFixed(10));
            if (fixedValue < min) {
                return min;
            } else if (fixedValue > max) {
                return max;
            } else {
                return fixedValue;
            }
        }
    };

    Slider.prototype._clickWrapper = function _clickWrapper(e) {
        if (this.get('disabled') || this.get('_isDragging')) return;

        var currentPosition = e.clientX;
        var newValue = this._getSlidingValue(currentPosition);
        if (this.get('isRange')) {
            newValue = this._generateRangeValue(newValue);
        }

        this._setFixedValue(newValue);
    };

    Slider.prototype._generateRangeValue = function _generateRangeValue(v) {
        var _get3 = this.get('value'),
            min = _get3[0],
            max = _get3[1];

        if (Math.abs(min - v) <= Math.abs(max - v)) {
            return [v, max];
        } else {
            return [min, v];
        }
    };

    Slider.prototype._getSlidingValue = function _getSlidingValue(pos) {
        var rect = this.$slider.getBoundingClientRect();
        var percent = (pos - rect.left) / rect.width;

        var _get4 = this.get(),
            max = _get4.max,
            min = _get4.min;

        var sliderWidth = max - min;

        if (percent <= 0) {
            return min;
        } else if (percent >= 1) {
            return max;
        } else {
            return min + sliderWidth * percent;
        }
    };

    Slider.prototype._onDrag = function _onDrag(indexFlag, e) {
        if (this.get('disabled')) return;

        this._isDragging = true;

        // when start drag, the element has been focusin
        // so we need not handle it here

        this.__onRangeSliding = this._onRangeSliding.bind(this, indexFlag);
        this.__onRangeSlideEnd = this._onRangeSlideEnd.bind(this, indexFlag);
        window.addEventListener('mousemove', this.__onRangeSliding);
        window.addEventListener('mouseup', this.__onRangeSlideEnd);
    };

    Slider.prototype._onRangeSliding = function _onRangeSliding(indexFlag, e) {
        var tempValue = this._getSlidingValue(e.clientX, this.get('_isDragging'));
        var fixedValue = void 0;

        tempValue = this._getTempValue(tempValue, indexFlag, this._min, this._max, indexFlag === '_isFirst');

        fixedValue = this._getFixedValue(tempValue);

        this.set({
            value: fixedValue,
            _inputValue: fixedValue,
            _sliderValue: tempValue
        });
    };

    Slider.prototype._getTempValue = function _getTempValue(value, isRange, min, max, isFirst) {
        if (isRange) {
            if (isFirst) {
                return [Math.min(value, max), Math.max(value, max)];
            } else {
                return [Math.min(value, min), Math.max(value, min)];
            }
        }
        return value;
    };

    Slider.prototype._onRangeSlideEnd = function _onRangeSlideEnd(indexFlag, e) {
        if (this.get('_isDragging')) {
            this.set('_isDragging', false, { async: true });
            var newValue = this._getSlidingValue(e.clientX);
            if (indexFlag) {
                if (indexFlag === '_isFirst') {
                    this.$sliderFirstBtn.blur();

                    this.set('_isFirst', false, { async: true });
                    newValue = [Math.min(newValue, this._max), Math.max(newValue, this._max)];
                } else {
                    this.$sliderSecondBtn.blur();

                    this.set('_isSecond', false, { async: true });
                    newValue = [Math.min(newValue, this._min), Math.max(newValue, this._min)];
                }
            } else {
                this.$sliderFirstBtn.blur();
            }

            this._setFixedValue(newValue);

            this.trigger('stop', this.get('value'));

            window.removeEventListener('mousemove', this.__onRangeSliding);
            window.removeEventListener('mouseup', this.__onRangeSlideEnd);

            this._isDragging = false;
        }
    };

    Slider.prototype._onFocusin = function _onFocusin(indexFlag, e) {
        if (this.get('disabled')) return;

        // if the focusin is invoked by dragging
        // let the handle element blur
        // because k-active will add focus style
        if (this._isDragging) {
            e.target.blur();
        }

        if (this.get('isRange')) {
            var value = this.get('value');
            this._min = value[0];
            this._max = value[1];
            if (indexFlag === '_isFirst') {
                this._initValue = this._min;
                this.set({
                    _isDragging: true,
                    _isFirst: true,
                    _isSecond: false
                });
            } else {
                this._initValue = this._max;
                this.set({
                    _isDragging: true,
                    _isFirst: false,
                    _isSecond: true
                });
            }
        } else {
            this.set('_isDragging', true);
        }
    };

    Slider.prototype._onFocusout = function _onFocusout(indexFlag) {
        if (this.get('disabled') || this._isDragging) return;

        if (this.get('isRange')) {
            if (indexFlag === '_isFirst') {
                this.set('_isFirst', false, { async: true });
            } else {
                this.set('_isSecond', false, { async: true });
            }
        }

        this.set('_isDragging', false, { async: true });
    };

    Slider.prototype._onKeydown = function _onKeydown(indexFlag, e) {
        if (this.get('disabled')) return;

        var step = this.get('step');
        if (e.keyCode === 37) {
            // left
            this._setValue(indexFlag, -step);
        } else if (e.keyCode === 39) {
            // right
            this._setValue(indexFlag, step);
        }
    };

    Slider.prototype._setValue = function _setValue(indexFlag, step) {
        var value = this.get('value');

        if (!this.get('isRange')) {
            return this._setFixedValue(value + step);
        }

        this._initValue += step;
        this._initValue = this._fix(this._initValue);

        var _value = this._getTempValue(this._initValue, indexFlag, this._min, this._max, indexFlag === '_isFirst');

        this._setFixedValue(_value);

        // if overstep the boundary, reverse it
        if (indexFlag === '_isFirst') {
            if (this._initValue > this._max) {
                this.$sliderFirstBtn.blur();
                this.$sliderSecondBtn.focus();
            }
        } else if (indexFlag === '_isSecond') {
            if (this._initValue < this._min) {
                this.$sliderSecondBtn.blur();
                this.$sliderFirstBtn.focus();
            }
        }
    };

    Slider.prototype._setOneValue = function _setOneValue(v) {
        if (!this.get('isRange')) {
            this._setFixedValue(v);
        } else {
            this._setFixedValue(this._generateRangeValue(v));
        }
    };

    Slider.prototype._stopPropagation = function _stopPropagation(e) {
        /* istanbul ignore next */
        e.stopPropagation();
    };

    Slider.prototype._destory = function _destory() {
        this._onRangeSlideEnd();
    };

    (0, _createClass3.default)(Slider, [{
        key: 'template',
        get: function get() {
            return _index2.default;
        }
    }]);
    return Slider;
}(_intact2.default), _class.propTypes = {
    max: Number,
    min: Number,
    value: Number,
    isRange: Boolean,
    unit: String,
    isShowEnd: Boolean,
    isShowInput: Boolean,
    step: Number
}, _temp);
exports.default = Slider;
exports.Slider = Slider;